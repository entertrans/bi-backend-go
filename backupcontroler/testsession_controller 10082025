package siswa

import (
	"encoding/json"
	"fmt"
	"log"
	"math/rand"
	"strconv"
	"time"

	"github.com/entertrans/bi-backend-go/config"
	"github.com/entertrans/bi-backend-go/models"
	"gorm.io/gorm"
)

// Mulai test baru atau lanjutkan session yang ada - DIPERBAIKI
func StartTestSession(testID uint, nis string, kelasID uint) (*models.TestSession, error) {
	// Convert nis string to int
	nisInt, err := strconv.Atoi(nis)
	if err != nil {
		return nil, fmt.Errorf("NIS tidak valid: %w", err)
	}

	// Cari session terakhir untuk test + siswa ini
	var existingSession models.TestSession
	err = config.DB.
		Preload("Test").
		Where("test_id = ? AND siswa_nis = ?", testID, nisInt).
		Order("start_time DESC").
		First(&existingSession).Error

	// 🎯 JIKA SUDAH ADA SESSION YANG MASIH AKTIF
	if err == nil && existingSession.Status == "in_progress" {
		elapsedTime := time.Since(existingSession.StartTime)
		totalDuration := time.Duration(existingSession.Test.DurasiMenit) * time.Minute
		remainingTime := totalDuration - elapsedTime

		if remainingTime <= 0 {
			// Waktu habis, auto-submit
			endTime := existingSession.StartTime.Add(totalDuration)
			existingSession.Status = "submitted"
			existingSession.EndTime = &endTime
			existingSession.WaktuSisa = 0
			config.DB.Save(&existingSession)

			// Update status peserta menjadi "submitted"
			config.DB.Model(&models.TO_Peserta{}).
				Where("test_id = ? AND siswa_nis = ?", testID, nis).
				Update("status", "submitted")

			return nil, fmt.Errorf("waktu ujian sudah habis")
		}

		// Update waktu sisa
		existingSession.WaktuSisa = int(remainingTime.Seconds())
		config.DB.Save(&existingSession)

		// ✅ KEMBALIKAN SESSION YANG SUDAH ADA + CEK SOAL SUDAH DISIMPAN
		log.Printf("🟢 Menggunakan session yang sudah ada: ID=%d", existingSession.SessionID)
		return &existingSession, nil
	}

	// 🎯 JIKA SUDAH SUBMITTED
	if err == nil && existingSession.Status == "submitted" {
		return nil, fmt.Errorf("anda sudah menyelesaikan test ini")
	}

	// 🎯 JIKA BELUM ADA SESSION → BUAT BARU
	var test models.TO_Test
	if err := config.DB.First(&test, testID).Error; err != nil {
		return nil, fmt.Errorf("test tidak ditemukan: %w", err)
	}

	startTime := time.Now()
	endTime := startTime.Add(time.Duration(test.DurasiMenit) * time.Minute)

	session := models.TestSession{
		TestID:     testID,
		SiswaNIS:   nisInt,
		KelasID:    kelasID, // ✅ tambahkan kelas snapshot di sini
		StartTime:  startTime,
		EndTime:    &endTime,
		WaktuSisa:  test.DurasiMenit * 60,
		Status:     "in_progress",
		NilaiAkhir: 0,
	}

	err = config.DB.Create(&session).Error
	if err != nil {
		return nil, fmt.Errorf("gagal membuat session: %w", err)
	}

	// 📝 UPDATE STATUS PESERTA MENJADI "in_progress"
	result := config.DB.Model(&models.TO_Peserta{}).
		Where("test_id = ? AND siswa_nis = ?", testID, nis).
		Update("status", "in_progress")

	if result.Error != nil {
		log.Printf("⚠️ Gagal update status peserta: %v", result.Error)
	} else if result.RowsAffected == 0 {
		log.Printf("⚠️ Data peserta tidak ditemukan untuk test_id=%d, nis=%s", testID, nis)
		// Optional: Buat data peserta jika belum ada
		peserta := models.TO_Peserta{
			TestID:    testID,
			SiswaNIS:  nis,
			Status:    "in_progress",
			CreatedAt: time.Now(),
			UpdatedAt: time.Now(),
		}
		if err := config.DB.Create(&peserta).Error; err != nil {
			log.Printf("⚠️ Gagal membuat data peserta: %v", err)
		}
	}

	// 📦 AMBIL SOAL MENGGUNAKAN GetSoalByTestID1
	soalList, err := GetSoalByTestID1(testID)
	if err != nil {
		return nil, fmt.Errorf("gagal mengambil soal: %w", err)
	}

	// 🎲 ACAK SOAL JIKA DIBUTUHKAN
	if test.RandomSoal {
		rand.Seed(time.Now().UnixNano())
		rand.Shuffle(len(soalList), func(i, j int) { soalList[i], soalList[j] = soalList[j], soalList[i] })
	}

	// 💾 SIMPAN URUTAN SOAL FIX KE to_sessionsoal
	for i, soal := range soalList {
		sessionSoal := models.TO_SessionSoal{
			SessionID: session.SessionID,
			SoalID:    soal.SoalID,
			OrderNo:   i + 1,
		}
		if err := config.DB.Create(&sessionSoal).Error; err != nil {
			log.Printf("⚠️ Gagal menyimpan session soal %d: %v", i+1, err)
		}
	}

	log.Printf("✅ Session baru dibuat: ID=%d, %d soal disimpan ke to_sessionsoal", session.SessionID, len(soalList))

	return &session, nil
}

// Function untuk mengambil soal berdasarkan session_id (setelah disimpan)

// bikin DTO umum biar frontend nggak ribet
type SoalDTO struct {
	SoalID           uint                `json:"soal_id"`
	TipeSoal         string              `json:"tipe_soal"`
	Pertanyaan       string              `json:"pertanyaan"`
	LampiranID       *uint               `json:"lampiran_id"`
	Lampiran         *models.TO_Lampiran `json:"lampiran,omitempty"` // ✅ ubah ke TO_Lampiran
	PilihanJawaban   string              `json:"pilihan_jawaban"`
	JawabanBenar     string              `json:"jawaban_benar"`
	Status           string              `json:"status"`
	Bobot            float64             `json:"bobot"`
	JawabanTersimpan interface{}         `json:"jawaban_tersimpan,omitempty"`
}

// GetSoalBySessionID harus return []SoalDTO
func GetSoalBySessionID(sessionID uint) ([]SoalDTO, error) {
	// 1. ambil session
	var session models.TestSession
	if err := config.DB.First(&session, sessionID).Error; err != nil {
		return nil, fmt.Errorf("session tidak ditemukan")
	}

	// 2. ambil test → cek type_test
	var test models.TO_Test
	if err := config.DB.First(&test, session.TestID).Error; err != nil {
		return nil, fmt.Errorf("test tidak ditemukan")
	}

	// 3. ambil urutan soal
	var sessionSoals []models.TO_SessionSoal
	if err := config.DB.Where("session_id = ?", sessionID).Order("order_no ASC").Find(&sessionSoals).Error; err != nil {
		return nil, fmt.Errorf("gagal ambil urutan soal: %w", err)
	}

	// 4. ambil jawaban siswa (final)
	var jawabanFinal []models.JawabanFinal
	if err := config.DB.Where("session_id = ?", sessionID).Find(&jawabanFinal).Error; err != nil {
		log.Printf("⚠️ gagal ambil jawaban siswa: %v", err)
	}

	// bikin map untuk akses cepat
	jawabanMap := make(map[uint]interface{})
	for _, jf := range jawabanFinal {
		var parsed interface{}
		if err := json.Unmarshal([]byte(jf.JawabanSiswa.String()), &parsed); err == nil {
			jawabanMap[jf.SoalID] = parsed
		} else {
			jawabanMap[jf.SoalID] = jf.JawabanSiswa.String()
		}
	}

	var soalDTOs []SoalDTO

	// 5. ambil soal sesuai tipe test
	if test.TypeTest == "ub" {
		var soalIDs []uint
		for _, ss := range sessionSoals {
			soalIDs = append(soalIDs, ss.SoalID)
		}

		var soals []models.TO_BankSoal
		if err := config.DB.
			Where("soal_id IN ?", soalIDs).
			Preload("Lampiran").
			Find(&soals).Error; err != nil {
			return nil, fmt.Errorf("gagal ambil soal bank: %w", err)
		}

		// Buat map untuk lookup cepat
		soalMap := make(map[uint]models.TO_BankSoal)
		for _, s := range soals {
			soalMap[s.SoalID] = s
		}

		// SUSUN ULANG sesuai urutan di sessionSoals
		for _, ss := range sessionSoals {
			if s, ok := soalMap[ss.SoalID]; ok {
				soalDTOs = append(soalDTOs, SoalDTO{
					SoalID:           s.SoalID,
					TipeSoal:         s.TipeSoal,
					Pertanyaan:       s.Pertanyaan,
					LampiranID:       s.LampiranID,
					Lampiran:         s.Lampiran,
					PilihanJawaban:   s.PilihanJawaban,
					JawabanBenar:     s.JawabanBenar,
					Bobot:            s.Bobot,
					JawabanTersimpan: jawabanMap[s.SoalID],
				})
			}
		}
	} else {
		var soalIDs []uint
		for _, ss := range sessionSoals {
			soalIDs = append(soalIDs, ss.SoalID)
		}

		var soals []models.TO_TestSoal
		if err := config.DB.
			Where("testsoal_id IN (?)", soalIDs).
			Preload("Lampiran").
			Find(&soals).Error; err != nil {
			return nil, fmt.Errorf("gagal ambil soal test: %w", err)
		}

		for _, s := range soals {
			soalDTOs = append(soalDTOs, SoalDTO{
				SoalID:           s.TestsoalID,
				TipeSoal:         s.TipeSoal,
				Pertanyaan:       s.Pertanyaan,
				LampiranID:       s.LampiranID,
				Lampiran:         s.Lampiran, // ✅ FIX
				PilihanJawaban:   s.PilihanJawaban,
				JawabanBenar:     s.JawabanBenar,
				Bobot:            s.Bobot,
				JawabanTersimpan: jawabanMap[s.TestsoalID],
			})
		}
	}

	return soalDTOs, nil
}

// Get session aktif - DIPERBAIKI
func GetActiveTestSession(testID uint, nis string) (*models.TestSession, error) {
	nisInt, err := strconv.Atoi(nis)
	if err != nil {
		return nil, fmt.Errorf("NIS tidak valid: %w", err)
	}

	var session models.TestSession
	err = config.DB.
		Preload("Test").
		Where("test_id = ? AND siswa_nis = ?", testID, nisInt).
		Order("updated_at DESC").
		First(&session).Error

	if err != nil {
		return nil, err // Return error asli untuk dibedakan di handler
	}

	// ✅ CEK JIKA Test TIDAK NULL
	if session.Test == nil {
		return nil, fmt.Errorf("data test tidak ditemukan untuk session")
	}

	// ✅ HANYA PROSES JIKA MASIH IN_PROGRESS
	if session.Status == "in_progress" {
		elapsedTime := time.Since(session.StartTime)
		totalDuration := time.Duration(session.Test.DurasiMenit) * time.Minute
		remainingTime := totalDuration - elapsedTime

		if remainingTime <= 0 {
			// Waktu habis, auto-submit
			endTime := session.StartTime.Add(totalDuration)
			session.Status = "submitted"
			session.EndTime = &endTime
			session.WaktuSisa = 0

			if err := config.DB.Save(&session).Error; err != nil {
				return nil, fmt.Errorf("gagal menyimpan session: %w", err)
			}
		} else {
			// Update field sementara untuk response (tidak disimpan ke DB)
			session.WaktuSisa = int(remainingTime.Seconds())
		}
	}

	return &session, nil
}

// Ambil sesi siswa untuk 1 test
func GetTestSession(testID uint, nis string) (*models.TestSession, error) {
	var session models.TestSession
	err := config.DB.
		Preload("JawabanFinal").
		Where("test_id = ? AND siswa_nis = ?", testID, nis).
		First(&session).Error

	if err != nil {
		return nil, err
	}
	return &session, nil
}

// Submit test (update end_time & status jadi submitted)
func SubmitTestSession(sessionID uint) error {
	db := config.DB

	// Mulai transaction
	tx := db.Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	if err := tx.Error; err != nil {
		return err
	}

	// 1. Ambil semua data jawaban final dengan detail bobot dan tipe soal
	type JawabanDetail struct {
		FinalID      uint
		SoalID       uint
		TipeSoal     string
		Bobot        float64
		SkorObjektif float64
		SkorUraian   *float64
	}

	var jawabanDetails []JawabanDetail
	err := tx.Table("to_jawabanfinal jf").
		Select("jf.final_id, jf.soal_id, bs.tipe_soal, bs.bobot, jf.skor_objektif").
		Joins("JOIN to_banksoal bs ON jf.soal_id = bs.soal_id").
		Where("jf.session_id = ?", sessionID).
		Scan(&jawabanDetails).Error

	if err != nil {
		tx.Rollback()
		return fmt.Errorf("gagal mengambil detail jawaban: %v", err)
	}

	// 2. Hitung manual dengan logging detail
	totalSkorSiswa := 0.0
	totalSkorMaksimal := 0.0
	butuhReview := false

	log.Printf("=== DETAIL PERHITUNGAN NILAI SESSION %d ===", sessionID)

	for i, jd := range jawabanDetails {
		totalSkorMaksimal += jd.Bobot

		var skorSoal float64
		var keterangan string

		// Gunakan switch statement untuk tipe soal
		switch jd.TipeSoal {
		case "pg", "pg_kompleks", "bs", "matching":
			// Untuk soal objektif, skor_objektif SUDAH termasuk bobot
			skorSoal = jd.SkorObjektif
			keterangan = fmt.Sprintf("Objektif: %.2f (sudah termasuk bobot)", jd.SkorObjektif)

		case "uraian", "isian_singkat":
			// Tipe soal subjektif (butuh review guru)
			if jd.SkorUraian == nil {
				skorSoal = 0
				butuhReview = true
				keterangan = "Uraian/Isian: Belum dinilai (0)"
			} else {
				// Untuk uraian/isian, skor SUDAH termasuk bobot
				skorSoal = *jd.SkorUraian
				keterangan = fmt.Sprintf("Uraian/Isian: %.2f (sudah termasuk bobot)", *jd.SkorUraian)
			}

		default:
			skorSoal = 0
			keterangan = fmt.Sprintf("Tipe tidak dikenali: %s", jd.TipeSoal)
		}

		totalSkorSiswa += skorSoal

		log.Printf("Soal %d (ID:%d, Tipe:%s, Bobot:%.2f): %s",
			i+1, jd.SoalID, jd.TipeSoal, jd.Bobot, keterangan)
	}

	log.Printf("=== TOTAL ===")
	log.Printf("Total Skor Siswa: %.2f", totalSkorSiswa)
	log.Printf("Total Skor Maksimal: %.2f", totalSkorMaksimal)
	log.Printf("Butuh Review: %t", butuhReview)

	// 3. Hitung nilai akhir (dalam persentase)
	var nilaiAkhir float64
	if totalSkorMaksimal > 0 {
		nilaiAkhir = (totalSkorSiswa / totalSkorMaksimal) * 100
		log.Printf("Perhitungan: (%.2f / %.2f) × 100 = %.2f",
			totalSkorSiswa, totalSkorMaksimal, nilaiAkhir)
	} else {
		log.Printf("Perhitungan: Total maksimal 0, nilai akhir 0")
	}

	// 5. Update session
	updateData := map[string]interface{}{
		"end_time":    time.Now(),
		"status":      "submitted",
		"nilai_akhir": nilaiAkhir,
		"updated_at":  time.Now(),
	}

	if err := tx.Model(&models.TestSession{}).
		Where("session_id = ?", sessionID).
		Updates(updateData).Error; err != nil {
		tx.Rollback()
		return fmt.Errorf("gagal update session: %v", err)
	}

	// log.Printf("=== UPDATE SESSION BERHASIL ===")
	// log.Printf("Nilai Akhir: %.2f", nilaiAkhir)
	// log.Printf("Status: %s", status)

	// 6. Commit transaction
	return tx.Commit().Error
}

func SubmitTugasSession(sessionID uint) error {
	return config.DB.Model(&models.TestSession{}).
		Where("session_id = ?", sessionID).
		Update("status", "onqueue").Error
}

func SubmitSession(sessionID uint, tipeUjian string) error {
	db := config.DB

	// Tentukan join condition dan table yang benar
	var query *gorm.DB

	if tipeUjian == "ub" {
		// Untuk UB: join dengan to_banksoal
		query = db.Table("to_jawabanfinal jf").
			Select("bs.tipe_soal, bs.bobot, jf.skor_objektif, jf.skor_uraian").
			Joins("JOIN to_banksoal bs ON jf.soal_id = bs.soal_id").
			Where("jf.session_id = ?", sessionID)
	} else {
		// Untuk Non-UB: join dengan to_testsoal, tapi perhatikan kolomnya!
		query = db.Table("to_jawabanfinal jf").
			Select("bs.tipe_soal, bs.bobot, jf.skor_objektif, jf.skor_uraian").
			Joins("JOIN to_testsoal bs ON jf.soal_id = bs.testsoal_id"). // PASTIKAN INI!
			Where("jf.session_id = ?", sessionID)
	}

	tx := db.Begin()
	if tx.Error != nil {
		return tx.Error
	}

	// Ambil data jawaban
	var jawabanDetails []struct {
		TipeSoal     string
		Bobot        float64
		SkorObjektif float64
		SkorUraian   *float64
	}

	err := query.Scan(&jawabanDetails).Error
	if err != nil {
		tx.Rollback()
		log.Printf("❌ Error mengambil jawaban: %v", err)
		return err
	}

	log.Printf("🔍 DEBUG SubmitSession: Found %d jawaban details for session %d", len(jawabanDetails), sessionID)

	for i, jd := range jawabanDetails {
		log.Printf("🔍 DEBUG Jawaban %d: Tipe=%s, Bobot=%.2f, SkorObj=%.2f, SkorUraian=%v",
			i+1, jd.TipeSoal, jd.Bobot, jd.SkorObjektif, jd.SkorUraian)
	}

	// Hitung nilai
	totalSkorSiswa, totalSkorMaksimal, butuhReview := 0.0, 0.0, false

	for _, jd := range jawabanDetails {
		totalSkorMaksimal += jd.Bobot

		skorSoal := jd.SkorObjektif
		if jd.TipeSoal == "uraian" || jd.TipeSoal == "isian_singkat" {
			if jd.SkorUraian != nil {
				skorSoal = *jd.SkorUraian
			} else {
				skorSoal, butuhReview = 0, true
			}
		}

		totalSkorSiswa += skorSoal
	}

	log.Printf("🔍 DEBUG Perhitungan: TotalSiswa=%.2f, TotalMaksimal=%.2f, ButuhReview=%t",
		totalSkorSiswa, totalSkorMaksimal, butuhReview)

	// Update session
	nilaiAkhir := 0.0
	if totalSkorMaksimal > 0 {
		nilaiAkhir = (totalSkorSiswa / totalSkorMaksimal) * 100
	}

	// Default status
	status := "submitted"
	// if butuhReview {
	// 	status = "onqueue"
	// }

	// 🔸 Kalo tipe ujian = tugas, paksa status jadi "onqueue"
	if tipeUjian == "tugas" {
		status = "onqueue"
	}

	err = tx.Model(&models.TestSession{}).
		Where("session_id = ?", sessionID).
		Updates(map[string]interface{}{
			"end_time":    time.Now(),
			"status":      status,
			"nilai_akhir": nilaiAkhir,
			"updated_at":  time.Now(),
		}).Error

	if err != nil {
		tx.Rollback()
		return err
	}

	log.Printf("✅ Session %d submitted: Nilai=%.2f, Status=%s", sessionID, nilaiAkhir, status)

	return tx.Commit().Error
}

// GET /siswa/test/:test_id/soal
func GetSoalByTestID1(testID uint) ([]models.TO_BankSoal, error) {
	// Ambil data test
	var test models.TO_Test
	if err := config.DB.First(&test, testID).Error; err != nil {
		return nil, fmt.Errorf("test tidak ditemukan")
	}

	// Jika tipe test adalah UB -> ambil soal dari relasi to_test_soal (TO_TestSoalRelasi)
	if test.TypeTest == "ub" {
		// Ambil relasi yang dipilih guru (urutkan by id supaya mengikuti urutan insert guru)
		var relasi []models.TO_TestSoalRelasi
		if err := config.DB.
			Where("test_id = ?", test.TestID).
			Order("id ASC").
			Find(&relasi).Error; err != nil {
			return nil, fmt.Errorf("gagal ambil relasi soal: %w", err)
		}
		if len(relasi) == 0 {
			return nil, fmt.Errorf("belum ada soal yang dipilih guru untuk test ini")
		}

		// Kumpulkan soalIDs sesuai urutan relasi
		soalIDs := make([]uint, 0, len(relasi))
		for _, r := range relasi {
			soalIDs = append(soalIDs, r.SoalID)
		}

		// Ambil semua TO_BankSoal yang berkaitan (GORM biasanya meng-ignore soft deleted)
		var bankSoals []models.TO_BankSoal
		if err := config.DB.
			Where("soal_id IN ?", soalIDs).
			Preload("Guru").
			Preload("Kelas").
			Preload("Mapel").
			Preload("Lampiran").
			Find(&bankSoals).Error; err != nil {
			return nil, fmt.Errorf("gagal ambil bank soal: %w", err)
		}

		// Reorder hasil DB supaya sesuai urutan soalIDs (karena IN() tidak menjaga urutan)
		mapSoal := make(map[uint]models.TO_BankSoal, len(bankSoals))
		for _, s := range bankSoals {
			mapSoal[s.SoalID] = s
		}

		ordered := make([]models.TO_BankSoal, 0, len(soalIDs))
		for _, id := range soalIDs {
			if s, ok := mapSoal[id]; ok {
				ordered = append(ordered, s)
			}
		}

		return ordered, nil
	}

	// Jika tipe test adalah tr / tugas -> pakai tabel to_testsoal (soal khusus test)
	if test.TypeTest == "tr" || test.TypeTest == "tugas" {
		var testSoal []models.TO_TestSoal
		if err := config.DB.Where("test_id = ?", test.TestID).Order("testsoal_id ASC").Find(&testSoal).Error; err != nil {
			return nil, fmt.Errorf("gagal ambil soal khusus test: %w", err)
		}

		// Konversi ke bentuk TO_BankSoal-like supaya frontend tetap konsisten
		var res []models.TO_BankSoal
		for _, ts := range testSoal {
			res = append(res, models.TO_BankSoal{
				SoalID:         ts.TestsoalID,
				TipeSoal:       ts.TipeSoal,
				Pertanyaan:     ts.Pertanyaan,
				LampiranID:     ts.LampiranID,
				PilihanJawaban: ts.PilihanJawaban,
				JawabanBenar:   ts.JawabanBenar,
				Bobot:          ts.Bobot,
				CreatedAt:      ts.CreatedAt,
			})
		}
		return res, nil
	}

	return nil, fmt.Errorf("tipe test tidak dikenali: %s", test.TypeTest)
}
